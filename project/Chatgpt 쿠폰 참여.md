
### 1) “사용자가 쿠폰 이벤트 참여를 신청한다” (엔드포인트 설계)

**장점**

- 단순 REST/HTTP로 빠르게 구축 가능.
    
- 비상 시 트래픽 셰이핑(429)·서킷브레이커 적용 용이.
    

**단점**

- 재시도/중복 클릭/네트워크 재전송으로 **이중처리** 가능성.
    
- 봇/스크립트 트래픽 유입 시 백엔드·Redis 과부하.
    

**면접 공격 포인트**

- **멱등성 보장**을 어떻게? → `Idempotency-Key` 헤더(+ TTL)로 단기(수 초) 중복제출 흡수.
    
- **레이트 리밋**/봇 방어? → 사용자·IP·디바이스 단위 토큰버킷( Redis ) 적용.
    
- 이벤트 **타임윈도우 기준 시각**은 누구 시간? → WAS가 아닌 Redis `TIME` 또는 단일 타임소스 사용으로 시계 드리프트 방지.
    

---

### 2) “LB는 WAS 둘 중 하나로 로드밸런싱”

**장점**

- 간단한 이중화, 무중단 배포/헬스체크 가능.
    

**단점**

- “둘 중 하나”만 명시 → **수평 확장 한계** 암시.
    
- 세션 스티키 필요 시 상태 관리 문제. (권장: 완전 무상태 + 쿠키/토큰)
    

**면접 공격 포인트**

- 한 리전에 **두 대만**? AZ/리전 장애 시? → 멀티 AZ + 오토스케일, 커넥션 드레이닝, 실패시 **재시도 폭풍**(retry storm) 억제 전략(지수백오프/재시도 상한)을 설명.
    
- 헬스체크 종류(L4/L7)와 장애 감지/격리(Outlier detection) 구체화 요구.
    

---

### 3) “WAS → Redis로 중복 참여 검증”

#### 3-1) 쿠키값으로 즉시 중복 반환(있으면 바로 중복)

**장점**

- **초저지연**(로컬 판정), Redis 부하 감소.
    

**단점**

- 쿠키 삭제/프라이빗 모드/기기 변경 시 **미스**.
    
- **위·변조** 가능 → 반드시 **서명(HMAC) + HttpOnly + Secure + SameSite**로 “힌트”로만 사용, **진실은 서버**(Redis)에서 판정.
    

**면접 공격 포인트**

- 쿠키만 믿으면? → 조작/유실. 항상 서버 검증 2차 단계 필요.
    
- 다중 디바이스/브라우저 간 정합성? → 서버 측 상태(아래 3-2)가 단일 원천.
    

#### 3-2) Redis **비트맵(Bitmap)**으로 중복 판정

**장점**

- O(1) 조회/설정, **메모리 효율**(1명 = 1비트).
    
    - 예: 1,000만 명 → 약 **1.25 MB** 원시 비트 용량(키 오버헤드는 소량).
        

**단점 & 주의**

- **전제 조건**: 사용자 ID가 “**조밀한 정수 범위**”여야 안전. 스파스/해시 ID면 인덱스 폭발·충돌/낭비.
    
- **핫키** 문제: 비트맵은 보통 **한 개 키**→ Redis Cluster에서 **단일 샤드 병목**.
    
- **TOCTOU 경쟁**: 동시 두 요청이 서로 GETBIT=0 확인 뒤 둘 다 SETBIT 할 수 있음 → **원자적 스크립트** 필수.
    

**면접 공격 포인트**

- 스파스 ID면? → 비트맵 대신 `SET`(SADD) 사용(정확, 메모리 ↑), 또는 **Bloom은** 오탐(f.p.) 있으니 **최종 판정**엔 부적합(힌트로만).
    
- 클러스터에서 원자성? → **Lua 스크립트**로 `GETBIT+SETBIT+(큐적재)`를 **동일 슬롯**에서 처리. (키 이름에 해시태그 `{...}`로 샤드 고정, 큐도 샤드별로 분산)
    
- 내구성? → AOF(everysec) + 복제 + `WAIT`(선택)로 내구성/지연 트레이드오프 설명 필요.
    

> **권장 판정 스크립트(개념)**  
> `if GETBIT(key, offset)==1 then return DUP else SETBIT(...)=1; XADD(참여로그) ; return OK end`  
> (**한 스크립트**에서 수행 → 중복판정과 큐 적재의 **원자성** 확보)

---

## 4) “인메모리 큐 → (주기적으로) Redis 우선순위 큐로 옮긴다”의 효율 전략

> **핵심 제안**: 가능하면 **인메모리 큐를 없애고** 요청 처리 경로에서 **즉시 Redis로 기록**하라. 인메모리는 “마이크로 배치 버퍼” 수준으로만 쓰고, 데이터의 **단일 진실 원천(SOR)**은 Redis가 되도록.

### 왜 인메모리 큐를 최소화?

- **데이터 유실**: 프로세스 크래시 시 미플러시 데이터 손실.
    
- **이중화 어려움**: 다대 WAS의 각 로컬 큐를 합치는 비용·복잡성 증가.
    

### 그래도 인메모리 버퍼를 써야 한다면 (초저지연/피크 완충)

- **마이크로 배치**: N건 또는 T ms 마다 **파이프라인으로 XADD/ZADD**(왕복 RTT↓, CPU/네트워크↑ 절약).
    
- **WAL(Write-Ahead Log)**: 플러시 전 **로컬 Append-only 파일**에도 기록해 **프로세스 크래시 복구**.
    
- **백프레셔**: Redis 지연↑ 시 WAS가 **수용량을 낮추고 429**를 내보내도록.
    

### 어떤 Redis 큐를 쓸까?

1. **Redis Streams + Consumer Groups (권장)**
    
    - **지속성/재처리**: 펜딩/ACK/리드 트래킹으로 **at-least-once**.
        
    - **우선순위**: **우선순위별 스트림 분리**(예: `event:{shard}:hi`, `:normal`) 후 컨슈머가 high → normal 순서로 읽음.
        
    - **모니터링**: `XINFO`로 **lag**/펜딩 관측, **DLQ**(데드레터 스트림) 운영.
        
2. **Sorted Set(ZSET) 기반 Priority Queue**
    
    - 점수: `priority * 1e13 + timestamp`로 **우선순위 우선, 동순위 FIFO**.
        
    - 단, 재처리/가시성 타임아웃 직접 구현 필요 → **Streams 대비 운영부담↑**.
        

> **결론**: **일관성/유실 방지** 중시 시 Streams, **단순/가벼움** 중시 시 ZSET. 첫 기준이 비슷하면 **리소스**로 선택:
> 
> - 메모리: ZSET(스코어+멤버) > Streams(필드 압축) ≈ 비슷.
>     
> - CPU: Streams가 컨슈머 관리 내장이라 오버헤드↓.
>     
> - 비용: 샤딩 수/복제 수에 비례.
>     

---

## 5) “당첨자 선정” 효율 전략

### A) **선착순(즉시 할당)** — “들어오는 즉시 당첨/대기”

- **원자 스크립트**로 한 번에 처리:
    
    1. 중복 판정(비트/SET)
        
    2. **잔여 쿼터 확인**(`GET winners:count < limit`)
        
    3. 가능하면 `INCR winners:count` + `SADD winners` + 결과 반환
        
    4. 큐/로그 기록
        
- 이 과정을 **하나의 Lua**로, 그리고 **동일 슬롯**에서 수행.
    
- **장점**: 응답 즉시 결과 전달, 운영 간단.
    
- **단점**: 트래픽 몰림 시 **쿼터 키 핫스팟**. → **샤딩된 카운터**(예: 32개 `wcnt:{i}`에 분산 증가 후 합산) + **배타적 창**(ms 단위)을 둬 스파이크 완화.
    

### B) **랜덤 추첨** — 공정성/감사 용이

두 가지 현실적인 방법:

1. **Commit–Reveal 기반 해시 정렬 방식(감사 친화)**
    
    - 이벤트 시작 전 **비밀 시드의 해시(commit)**를 공개 저장.
        
    - 종료 후 시드(reveal) 공개.
        
    - 각 참가자에 대해 `H = SHA-256(seed || eventId || userId)` 계산, **H 오름차순 상위 N**을 **당첨**.
        
    - **장점**: 조작 불가·재현 가능, **대규모에도 균등**.
        
    - **리소스**: 전체 후보를 한 번 스캔(Streams/SET/비트맵 스캔)하며 **상위 N 유지**(크기 N의 최대힙) → **메모리 O(N)**.
        
2. **Reservoir Sampling(스트리밍 균등 표본추출)**
    
    - 소비자가 **스트림을 한 바퀴** 읽으면서 **크기 N의 저장소** 유지.
        
    - **장점**: **한 번의 패스, 메모리 O(N)**, 실시간에 가까운 선정 가능.
        
    - **단점**: 감사 용이성 측면은 해시정렬 방식이 더 낫다(시드 공개로 검증 쉬움).
        

> **권장**: 공정성과 감사가 중요하면 **Commit–Reveal 해시정렬**, 실시간성/간결함이 우선이면 **Reservoir**.

---

## 데이터 일관성 / 응답속도 / 확장성 / 유실 방지 — 체크리스트

- **원자성**: `GETBIT/SETBIT + 큐적재 + (선탁/랜덤 메타)`를 **하나의 Lua**로 처리.
    
- **샤딩**:
    
    - 비트맵/집합/스트림을 **샤드 키(예: `event:{shard}`)**로 분산.
        
    - 스크립트는 **동일 슬롯** 키들만 사용(클러스터 제약).
        
- **내구성**: Redis **AOF everysec** + **Replica 1–2** + (선택) `WAIT 1 50`(1개 레플리카 50ms까지 대기).
    
- **장애 대응**: Redis 장애 시 **즉시 503/대기열 안내**(잘못된 “당첨/중복” 응답을 절대 반환하지 말 것).
    
- **타임라인**: 이벤트 단위 키에 **TTL** 설정(`participated:{event}:*`, `bitmap:{event}:*`, `stream:{event}:*`)로 메모리 회수.
    
- **감사/추적**: 모든 결정을 **Streams 로그**에 남기고, 선정 시점·시드·해시·유저ID(또는 해시화된 ID) 기록.
    

---

## “리소스(메모리/CPU/네트워크/비용)” 관점 세부 전략

### 메모리

- **Bitmap**: ID가 조밀할 때 최강 효율.
    
    - 1,000만 명 ≈ **1.25MB**(원시 비트 기준).
        
- **SET(SADD)**: 사용자당 수십 바이트(멤버/오버헤드).
    
    - 100만 명 ≈ 대략 **수십~100MB대**.
        
- **Streams**: 필드 수/길이에 비례. 불필요한 필드는 빼서 크기 최소화(예: `uid`, `ts`, `meta` 정도).
    

### CPU

- **파이프라이닝**과 **배치 플러시**로 syscall/RTT 절감.
    
- 초고QPS 시 **간단 연산**(BIT/INCR) 유지, 복잡한 선정 로직은 **오프라인/백그라운드 컨슈머**로 분리.
    

### 네트워크

- **커넥션 풀 + Keep-Alive**, 재시도는 **지수백오프 + Jitter**.
    
- 대량 배치 시 **Nagle 비활성**(클라이언트/드라이버 디폴트 확인).
    

### 비용

- **샤드 수**는 **P95 지연/메모리 사용률**로 점진 증설.
    
- 복제본 수(가용성)와 쓰기 대기(`WAIT`)는 **지연/비용 트레이드오프**로 조절.
    

---

## 키 설계(예시)

- 참여중복 비트맵(샤드 32개): `ev:{E}:{s}:bm` (offset = userId)
    
- 참여집합(대체안): `ev:{E}:{s}:set` (멤버 = userId)
    
- 스트림(우선순위별): `ev:{E}:{s}:x:hi`, `ev:{E}:{s}:x:norm`
    
- 당첨카운터(샤드): `ev:{E}:wcnt:{i}`
    
- 당첨자 집합: `ev:{E}:winners`
    
- 시드/커밋: `ev:{E}:seed:commit`, `ev:{E}:seed:reveal`
    

---

## 운영/모니터링 포인트

- **Redis 레이턴시 p95/p99**, 명령별 QPS, 연결 수.
    
- **Streams Lag**(컨슈머 그룹별), **펜딩 길이**(장시간 펜딩 알람).
    
- **AOF 재작성**/RDB 스냅샷 시 레이턴시 변동 감시.
    
- **당첨 카운터 불일치** 감지(샤드 합계 vs 공개 수치).
    
- **DLQ**(처리 실패 이벤트) 비정상 증가 알람.
    

---

## 마무리 추천안 (요약)

1. **쿠키는 힌트**(서명/보안 설정 필수), **최종 판정은 Redis**.
    
2. **비트맵**은 **조밀 정수 ID**일 때만. 아니면 **SET(SADD)**로 정확 판정.
    
3. **원자 Lua**로 **중복판정 + 큐적재(+선착순 할당)**를 한 방에. **클러스터 슬롯** 주의.
    
4. **인메모리 큐 최소화**. 가능하면 즉시 **Redis Streams**로 XADD.
    
5. **당첨**은
    
    - **선착순**이면 카운터+원자 스크립트,
        
    - **랜덤**이면 **Commit–Reveal 해시정렬**(감사 우수) 또는 **Reservoir**(리소스 효율).
        
6. 내구성은 **AOF everysec + 복제 + (선택) WAIT**, TTL로 데이터 수명 관리.
    

이 구성은 **일관성**(원자/로그), **응답속도**(쿠키 힌트+O(1) 연산), **확장성**(샤딩/스트림 컨슈머 수평확장), **유실 방지**(Streams/AOF/복제) 기준을 우선 만족시키고, 동률일 땐 **메모리/CPU/네트워크/비용** 관점에서 장비/파라미터를 고르는 방식입니다.